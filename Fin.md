# Быстрое начало

Хотите начать? На этой странице представлено хорошее введение в то, как начать работу с запросами.

Во-первых, убедитесь, что:

+ Запросы установлены
+ Запросы актуальны

Начнем с простых примеров 

# Сделать запрос

Сделать запрос с помощью Requests очень просто.

Начните с импорта модуля Requests: import requests

```python
>>>import requests
```

Теперь попробуем получить веб-страницу. Для этого примера давайте возьмем общедоступную временную шкалу GitHub:

```python
>>>r = requests.get('https://api.github.com/events') 
```

Теперь у нас есть объект **Response** с именем `r`. Мы можем получить всю необходимую информацию из этого объекта.

Простой API запросов означает, что все формы HTTP-запросов одинаково очевидны. Например, вот как вы делаете запрос HTTP POST:

```python
>>>r = requests.post('https://httpbin.org/post', data={'key': 'value'}) 
```

Приятно, правда? А как насчет других типов HTTP-запросов: PUT, DELETE, HEAD и OPTIONS? Все так же просто:

```python
>>>r = requests.put('https://httpbin.org/put', data={'key': 'value'}) 
>>>r = requests.delete('https://httpbin.org/delete') 
>>>r = requests.head('https://httpbin.org/get') 
>>>r = requests.options('https://httpbin.org/get')
```

Это все хорошо, но это только начало того, на что способны Requests. _**Сеня**_

# Содержание ответа

Мы можем прочитать содержимое ответа сервера. Рассмотрим еще раз временную шкалу GitHub:

```python
>>> import requests

>>> r = requests.get('https://api.github.com/events')
>>> r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...
```

Запросы будут автоматически декодировать контент с сервера. Большинство наборов символов Unicode легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, угаданная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя r.encoding свойство:

```python
>>> r.encoding
'utf-8'
>>> r.encoding = 'ISO-8859-1'
```
Если вы измените кодировку, запросы будут использовать новое значение r.encodingвсякий раз, когда вы вызываете r.text. Вы можете захотеть сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка содержимого. Например, HTML и XML имеют возможность указывать свою кодировку в своем теле. В таких ситуациях вы должны использовать , r.contentчтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.textс правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали собственную кодировку и зарегистрировали ее в codecsмодуле, вы можете просто использовать имя кодека в качестве значения, r.encodingи Запросы обработают декодирование за вас.

# Содержимое двоичного ответа

Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:

```python
>>> r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...
```

Кодировки gzip и deflate передачи автоматически декодируются для вас.

Кодировка передачи br автоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi.

Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, можно использовать следующий код:

```python
>>> from PIL import Image
>>> from io import BytesIO

>>> i = Image.open(BytesIO(r.content))
```
_**Лимур**_
