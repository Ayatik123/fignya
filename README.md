# Перевод текста
Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:

import requests

r = requests.get('https://api.github.com/events')
r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...

Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:

r.encoding
'utf-8'
r.encoding = 'ISO-8859-1'

Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.




# Authentication
# Аутентификация
В этом документе обсуждается использование различных видов аутентификации с запросами.

Многие веб-сервисы требуют аутентификации, и существует множество различных типов. Ниже мы описываем различные формы аутентификации, доступные в Requests, от простых до сложных.

# Базовая аутентификация - Basic Authentication
Многие веб-сервисы, требующие аутентификации, принимают HTTP Basic Auth. Это самый простой вид, и Requests поддерживает его прямо из "коробки".

Выполнять запросы с помощью HTTP Basic Auth очень просто:

from requests.auth import HTTPBasicAuth basic = HTTPBasicAuth('user', 'pass') requests.get('https://httpbin.org/basic-auth/user/pass', auth=basic) <Response [200]>

На самом деле, HTTP Basic Auth настолько распространен, что запросы предоставляют удобное сокращение для его использования:

requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass')) <Response [200]>

Предоставление учетных данных в кортеже, подобном этому, как в HTTP Basic Auth примере выше.

# Аутентификационная сеть - netrc Anuthentication
Если метод аутентификации не указан с auth аргументом, запрос попытается получить учетные данные аутентификации для имени хоста URL из файла сети пользователя. Файл netrc переопределяет необработанные заголовки аутентификации HTTP, установленные с помощью headers.

Если учетные данные для имени хоста найдены, запрос отправляется с помощью HTTP Basic Auth.

# Перевод текста
Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:

import requests

r = requests.get('https://api.github.com/events')
r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...

Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:

r.encoding
'utf-8'
r.encoding = 'ISO-8859-1'

Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.


