
# Аутентификация - Authentication
***В этом документе обсуждается использование различных видов аутентификации с запросами.***

***Многие веб-сервисы требуют аутентификации, и существует множество различных типов. Ниже мы описываем различные формы аутентификации, доступные в Requests, от простых до сложных.***

# Базовая аутентификация - Basic Authentication

***Многие веб-сервисы, требующие аутентификации, принимают HTTP Basic Auth. Это самый простой вид, и Requests поддерживает его прямо из "коробки".***

***Выполнять запросы с помощью HTTP Basic Auth очень просто:***

>>>from requests.auth import HTTPBasicAuth basic = HTTPBasicAuth('user', 'pass') requests.get('https://httpbin.org/basic-auth/user/pass', auth=basic) <Response [200]>

***На самом деле, HTTP Basic Auth настолько распространен, что запросы предоставляют удобное сокращение для его использования:***

>>>requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass')) <Response [200]>

***Предоставление учетных данных в кортеже, подобном этому, как в HTTP Basic Auth примере выше.***

# Аутентификационная сеть - netrc Anuthentication

***Если метод аутентификации не указан с auth аргументом, запрос попытается получить учетные данные аутентификации для имени хоста URL из файла сети пользователя. Файл netrc переопределяет необработанные заголовки аутентификации HTTP, установленные с помощью headers.***

***Если учетные данные для имени хоста найдены, запрос отправляется с помощью HTTP Basic Auth.***

# Дайджест-аутентификация

***Другой очень популярной формой HTTP-аутентификации является дайджест-аутентификация, и Requests также поддерживает ее «из коробки»:***

>>>   from requests.auth import HTTPDigestAuth
>>>   url = 'https://httpbin.org/digest-auth/auth/user/pass'
>>>   requests.get(url, auth=HTTPDigestAuth('user', 'pass'))
<Response [200]>

# Перевод текста

***Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:***

>>> import requests

>>> r = requests.get('https://api.github.com/events')
>>> r.text
>>> '[{"repository":{"open_issues":0,"url":"https://github.com/...

***Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.***

***Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:***

>>> r.encoding
>>> 'utf-8'
>>> r.encoding = 'ISO-8859-1'

***Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.***

***Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.***

# CUSTOM HEADERS

***Если вы хотите добавить заголовки http к запросу, то просто передайте словарь в параметр headers. Например, в предыдущем примере мы не указали наш user-agent: url = 'https://api.github.com/some/endpoint' headers = {'user-agent': 'my-app/0.0.1'}***

>>>r = requests.get(url, headers=headers)

***Примечание: пользовательские заголовки имеют меньший приоритет, чем более конкретные источники информации. Например:***

***- Заголовоки авторизации, установленные с помощью headers =, будут переопределены, если учетные данные указаны в .netrc, что, в свою очередь, будет переопределено параметром auth=. Запросы будут искать файл netrc в /netrc,/_netrc или по пути, указанному переменной среды NETRC.***
***- Заголовки авторизации будут удалены, если вы будете перенаправлены за пределы хоста.***
***- Заголовки Proxy-Authorization будут переопределены учетными данными прокси-сервера, указанными в URL-адресе.***
***- Заголовки Content-Length будут переопределены, когда мы сможем определить длину контента***
***Более того, запросы вообще не меняют свое поведение в зависимости от того, какие пользовательские заголовки указаны. Заголовки просто передаются в конечный запрос.***

***Примечание: все значения заголовков должны быть строкой, байт-тестированием или юникодом. Пока это разрешено, рекомендуется избегать передачи значений заголовков юникода***
*Ксюша*


# Содержание бинарного ответа-Binary-Reponse-Content  
 
***Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:***

>>>r.content
>>>b'[{"repository":{"open_issues":0,"url":"https://github.com/...

***Кодировки gzip и deflate передачи автоматически декодируются для вас.***

***Кодировка передачи br автоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi.***

**Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, можно использовать следующий код:**

>>>from PIL import Image
>>>from io import BytesIO

i = Image.open(BytesIO(r.content))
# **Quickstart **
Хотите начать? Эта страница дает хорошее введение в то, как начать работу с Requests.

Во-первых, убедитесь, что:

Запросы установлены

Запросы актуальны

Давайте начнем с простых примеров.

Сделать запрос 
Сделать запрос с помощью Requests очень просто.

Начните с импорта модуля «Запросы»:
import requests
Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline:

r = requests.get('https://api.github.com/events')
Now, we have a Response object called r. We can get all the information we need from this object.

Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request:

r = requests.post('https://httpbin.org/post', data={'key': 'value'})
Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple:

r = requests.put('https://httpbin.org/put', data={'key': 'value'})
r = requests.delete('https://httpbin.org/delete')
r = requests.head('https://httpbin.org/get')
r = requests.options('https://httpbin.org/get')
Это все хорошо, но это только начало того, что может сделать Requests.

Передача параметров в URL-адресах 
Часто требуется отправить какие-то данные в строке запроса URL. Если бы вы создавали URL вручную, эти данные были бы указаны в виде пар ключ/значение в URL после вопросительного знака, например httpbin.org/get?key=val. Requests позволяет вам предоставлять эти аргументы в виде словаря строк, используя paramsаргумент ключевого слова. Например, если вы хотите передать key1=value1и key2=value2в httpbin.org/get, вы бы использовали следующий код:
payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.get('https://httpbin.org/get', params=payload)
You can see that the URL has been correctly encoded by printing the URL:

print(r.url)
https://httpbin.org/get?key2=value2&key1=value1
Note that any dictionary key whose value is None will not be added to the URL’s query string.

You can also pass a list of items as a value:

payload = {'key1': 'value1', 'key2': ['value2', 'value3']}

r = requests.get('https://httpbin.org/get', params=payload)
print(r.url)
https://httpbin.org/get?key1=value1&key2=value2&key2=value3


Response Content****

Мы можем прочитать содержимое ответа сервера. Рассмотрим еще раз временную шкалу GitHub:
Запросы будут автоматически декодировать контент с сервера. Большинство наборов символов Unicode легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, угаданная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя r.encodingсвойство:
Если вы измените кодировку, запросы будут использовать новое значение r.encodingвсякий раз, когда вы вызываете r.text. Вы можете захотеть сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка содержимого. Например, HTML и XML имеют возможность указывать свою кодировку в своем теле. В таких ситуациях вы должны использовать , r.contentчтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.textс правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали собственную кодировку и зарегистрировали ее в codecsмодуле, вы можете просто использовать имя кодека в качестве значения, r.encodingи Запросы обработают декодирование за вас.
Binary Response Content
Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:

Binary Response Content

# Перевод текста
Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:

import requests

r = requests.get('https://api.github.com/events')
r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...

Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:

r.encoding
'utf-8'
r.encoding = 'ISO-8859-1'

Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.(Солонченко Кирилл)

Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:
r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...

Кодировки передачи gzip и deflate автоматически декодируются.

Кодировка передачи br автоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi.

Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, вы можете использовать следующий код:

from PIL import Image
from io import BytesIO

i = Image.open(BytesIO(r.content))


                                                                                                                     СДЕЛАТЬ ЗАПРОС¶
                                                                                                                     
Сделать запрос с помощью Requests очень просто.

Начните с импорта модуля Requests:
import requests

Теперь попробуем получить веб-страницу. Для этого примера давайте возьмем общедоступную временную шкалу GitHub:

r = requests.get('https://api.github.com/events')
Теперь у нас есть объект Response с именем r. Мы можем получить всю необходимую информацию из этого объекта.

Простой API запросов означает, что все формы HTTP-запросов одинаково очевидны. Например, вот как вы делаете запрос HTTP POST:
r = requests.post('https://httpbin.org/post', data={'key': 'value'})
Приятно, правда? А как насчет других типов HTTP-запросов: PUT, DELETE, HEAD и OPTIONS? Все так же просто:

r = requests.put('https://httpbin.org/put', data={'key': 'value'})
r = requests.delete('https://httpbin.org/delete')
r = requests.head('https://httpbin.org/get')
r = requests.options('https://httpbin.org/get')

Это все хорошо, но это только начало того, на что способны Requests.

                                                                                                                  TIMEOUTS

Вы можете указать Requests прекратить ожидание ответа через заданное количество секунд с помощью параметра timeout. Почти весь производственный код должен использовать этот параметр почти во всех запросах. Невыполнение этого требования может привести к зависанию вашей программы на неопределенный срок:

requests.get('https://github.com/', timeout=0.001)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)

Примечание
таймаут не является ограничением по времени на всю загрузку ответа; скорее, исключение возникает, если сервер не выдал ответ в течение таймаута (точнее, если в базовый сокет не было получено ни одного байта в течение таймаута). Если тайм-аут не указан явно, время ожидания запросов не истекает.

                                                                                                                 ERRORS AND EXCEPTIONS
                                                                                                                 
                                                                                                                 
 В случае возникновения сетевой проблемы (например, сбоя DNS, отказа в соединении и т. д.) запросы вызовут исключение ConnectionError.

Response.raise_for_status() вызовет HTTPError, если HTTP-запрос возвратил код состояния неудачи.

Если время ожидания запроса истекло, возникает исключение Timeout.

Если запрос превышает настроенное максимальное количество перенаправлений, возникает исключение TooManyRedirects.

Все исключения, которые Requests явно вызывает, наследуют от Requests.Exceptions.RequestException.

Если вы измените кодировку, запросы будут использовать новое значение r.encodingвсякий раз, когда вы вызываете r.text. Вы можете захотеть сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка содержимого. Например, HTML и XML имеют возможность указывать свою кодировку в своем теле. В таких ситуациях вы должны использовать , r.contentчтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.textс правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали собственную кодировку и зарегистрировали ее в codecsмодуле, вы можете просто использовать имя кодека в качестве значения, r.encodingи Запросы обработают декодирование за вас.
Binary Response Content¶
Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:

r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...
Кодировки gzipи deflateпередачи автоматически декодируются для вас.

Кодировка передачи brавтоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi .

Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, можно использовать следующий код:

from PIL import Image
from PIL import Image
from io import BytesIO

i = Image.open(BytesIO(r.content))\
JSON Response Content¶
В случае сбоя декодирования JSON r.json()вызывает исключение. Например, если ответ получает 204 (No Content) или если ответ содержит недопустимый JSON, попытка r.json()вызывает requests.exceptions.JSONDecodeError. Это исключение-обертка обеспечивает взаимодействие для нескольких исключений, которые могут быть выданы различными версиями Python и библиотеками сериализации JSON.

Следует отметить, что успешность вызова r.json()не указывает на успешность ответа. Некоторые серверы могут возвращать объект JSON в неудачном ответе (например, сведения об ошибке с HTTP 500). Такой JSON будет декодирован и возвращен. Чтобы проверить, что запрос успешен, используйте r.raise_for_status()или проверьте r.status_code, что вы ожидаете.
Содержание необработанного ответа 
В редком случае, когда вы хотите получить необработанный ответ сокета от сервера, вы можете обратиться к r.raw. Если вы хотите сделать это, убедитесь, что вы установили stream=Trueсвой начальный запрос. После этого вы можете сделать это:

r = requests.get('https://api.github.com/events', stream=True)

r.raw
<urllib3.response.HTTPResponse object at 0x101194810>

r.raw.read(10)
b'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'
Однако в общем случае для сохранения транслируемого потока в файл следует использовать следующий шаблон:

with open(filename, 'wb') as fd:
    for chunk in r.iter_content(chunk_size=128):
        fd.write(chunk)
Использование Response.iter_contentбудет обрабатывать многое из того, что вам пришлось бы обрабатывать при использовании Response.rawнапрямую. При потоковой передаче загрузки указанный выше способ является предпочтительным и рекомендуемым для получения контента. Обратите внимание, что его chunk_sizeможно свободно настроить на число, которое может лучше соответствовать вашим вариантам использования.

Примечание
Важное замечание об использовании Response.iter_contentversus Response.raw. Response.iter_contentавтоматически декодирует gzipи deflatetransfer-encodings. Response.raw— это необработанный поток байтов — он не преобразует содержимое ответа. Если вам действительно нужен доступ к байтам в том виде, в котором они были возвращены, используйте Response.raw.

Пользовательские заголовки 
Если вы хотите добавить HTTP-заголовки к запросу, просто передайте dictпараметру headers.

Например, в предыдущем примере мы не указали наш пользовательский агент:

url = 'https://api.github.com/some/endpoint'
headers = {'user-agent': 'my-app/0.0.1'}

r = requests.get(url, headers=headers)
Примечание: Пользовательские заголовки имеют меньший приоритет, чем более конкретные источники информации. Например:

Заголовки авторизации, установленные с помощью headers=, будут переопределены, если в .netrc, что в свою очередь будет переопределено параметром auth=. Запросы будут искать файл netrc в ~/.netrc , ~/_netrc или по пути, указанному переменной среды NETRC .

Заголовки авторизации будут удалены, если вы будете перенаправлены за пределы хоста.

Заголовки Proxy-Authorization будут переопределены учетными данными прокси-сервера, указанными в URL-адресе.

Заголовки Content-Length будут переопределены, когда мы сможем определить длину контента.

Более того, Requests вообще не меняет своего поведения в зависимости от того, какие пользовательские заголовки указаны. Заголовки просто передаются в конечный запрос.

Примечание: Все значения заголовков должны быть string, байтовой строкой или unicode. Хотя это разрешено, рекомендуется избегать передачи значений заголовков unicode.

Более сложные запросы POST 
Обычно вы хотите отправить некоторые данные в кодировке формы — очень похоже на форму HTML. Для этого просто передайте словарь аргументу data. Ваш словарь данных будет автоматически закодирован в кодировке формы при выполнении запроса:

payload = {'key1': 'value1', 'key2': 'value2'}

r = requests.post('https://httpbin.org/post', data=payload)
print(r.text)
{
  ...
  "form": {
    "key2": "value2",
    "key1": "value1"
  },
  ...
}
Аргумент dataтакже может иметь несколько значений для каждого ключа. Это можно сделать, создав dataлибо список кортежей, либо словарь со списками в качестве значений. Это особенно полезно, когда форма имеет несколько элементов, которые используют один и тот же ключ:

payload_tuples = [('key1', 'value1'), ('key1', 'value2')]
r1 = requests.post('https://httpbin.org/post', data=payload_tuples)
payload_dict = {'key1': ['value1', 'value2']}
r2 = requests.post('https://httpbin.org/post', data=payload_dict)
print(r1.text)
{
  ...
  "form": {
    "key1": [
      "value1",
      "value2"
    ]
  },
  ...
}
r1.text == r2.text
True
Бывают моменты, когда вам может понадобиться отправить данные, которые не закодированы в форме. Если вы передадите stringвместо dict, эти данные будут отправлены напрямую.

Например, GitHub API v3 принимает данные POST/PATCH в кодировке JSON:

import json

url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}

r = requests.post(url, data=json.dumps(payload))
Обратите внимание, что приведенный выше код НЕ добавит заголовок Content-Type(и, в частности, он НЕ установит его в значение application/json).

Если вам нужен этот набор заголовков и вы не хотите кодировать его dictсамостоятельно, вы также можете передать его напрямую с помощью jsonпараметра (добавлен в версии 2.4.2), и он будет закодирован автоматически:

url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
r = requests.post(url, json=payload)
Обратите внимание, что jsonпараметр игнорируется, если передано dataили .files

Отправка файла с многокомпонентной кодировкой 
Requests упрощает загрузку файлов, закодированных с помощью Multipart:

url = 'https://httpbin.org/post'
files = {'file': open('report.xls', 'rb')}

r = requests.post(url, files=files)
r.text
{
  ...
  "files": {
    "file": "<censored...binary...data>"
  },
  ...
}
Вы можете явно указать имя файла, тип содержимого и заголовки:

url = 'https://httpbin.org/post'
files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}

r = requests.post(url, files=files)
r.text
{
  ...
  "files": {
    "file": "<censored...binary...data>"
  },
  ...
}
При желании вы можете отправлять строки для получения в виде файлов:

url = 'https://httpbin.org/post'
files = {'file': ('report.csv', 'some,data,to,send\nanother,row,to,send\n')}

r = requests.post(url, files=files)
r.text
{
  ...
  "files": {
    "file": "some,data,to,send\\nanother,row,to,send\\n"
  },
  ...
}
В случае, если вы отправляете очень большой файл в качестве multipart/form-dataзапроса, вы можете захотеть транслировать запрос. По умолчанию requestsне поддерживает это, но есть отдельный пакет, который поддерживает - requests-toolbelt. Вам следует прочитать документацию toolbelt для получения более подробной информации о том, как его использовать.

Для отправки нескольких файлов в одном запросе обратитесь к расширенному разделу.
Для отправки нескольких файлов в одном запросе обратитесь к расширенному разделу.

Предупреждение
Настоятельно рекомендуется открывать файлы в двоичном режиме . Это связано с тем, что Requests может попытаться предоставить Content-Lengthзаголовок для вас, и если это произойдет, это значение будет установлено на количество байтов в файле. При открытии файла в текстовом режиме могут возникнуть ошибки .

Коды статуса ответа 
Мы можем проверить код статуса ответа:

r = requests.get('https://httpbin.org/get')
r.status_code
200
Запросы также содержат встроенный объект поиска кода статуса для удобства использования:

r.status_code == requests.codes.ok
True
Если мы сделали неверный запрос (ошибка клиента 4XX или ответ об ошибке сервера 5XX), мы можем вызвать его с помощью Response.raise_for_status():

bad_r = requests.get('https://httpbin.org/status/404')
bad_r.status_code
404

bad_r.raise_for_status()
Traceback (most recent call last):
  File "requests/models.py", line 832, in raise_for_status
    raise http_error
requests.exceptions.HTTPError: 404 Client Error
Но, поскольку наш status_codefor rбыл 200, при вызове raise_for_status()мы получаем:

r.raise_for_status()
None
Все хорошо.

Заголовки ответа 
Мы можем просмотреть заголовки ответа сервера, используя словарь Python:

r.headers
{
    'content-encoding': 'gzip',
    'transfer-encoding': 'chunked',
    'connection': 'close',
    'server': 'nginx/1.0.4',
    'x-runtime': '148ms',
    'etag': '"e1ca502697e5c9317743dc078f67693f"',
    'content-type': 'application/json'
}
Словарь особенный, хотя: он сделан только для HTTP-заголовков. Согласно RFC 7230 , имена HTTP-заголовков нечувствительны к регистру.

Итак, мы можем получить доступ к заголовкам, используя любую желаемую нами регистр букв:

r.headers['Content-Type']
'application/json'

r.headers.get('content-type')
'application/json'
Его особенностью также является то, что сервер мог отправить один и тот же заголовок несколько раз с разными значениями, но запросы объединяют их, чтобы они могли быть представлены в словаре в одном сопоставлении, согласно RFC 7230 :

Получатель МОЖЕТ объединить несколько полей заголовка с одинаковым именем поля в одну пару «имя-поля: значение-поля», не меняя семантику сообщения, путем добавления каждого последующего значения поля к объединенному значению поля по порядку, разделенному запятой.
Файлы cookie 
Если ответ содержит файлы cookie, вы можете быстро получить к ним доступ:

url = 'http://example.com/some/cookie/setting/url'
r = requests.get(url)

r.cookies['example_cookie_name']
'example_cookie_value'
Чтобы отправить собственные файлы cookie на сервер, вы можете использовать cookiesпараметр:

url = 'https://httpbin.org/cookies'
cookies = dict(cookies_are='working')

r = requests.get(url, cookies=cookies)
r.text
'{"cookies": {"cookies_are": "working"}}'
Файлы cookie возвращаются в RequestsCookieJar, который действует как , dictно также предлагает более полный интерфейс, подходящий для использования в нескольких доменах или путях. Файлы cookie также могут быть переданы в запросы:

jar = requests.cookies.RequestsCookieJar()
jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')
jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')
url = 'https://httpbin.org/cookies'
r = requests.get(url, cookies=jar)
r.text
'{"cookies": {"tasty_cookie": "yum"}}'
Перенаправление и история 
По умолчанию Requests будет выполнять перенаправление местоположения для всех глаголов, кроме HEAD.

Мы можем использовать historyсвойство объекта Response для отслеживания перенаправления.

Список Response.historyсодержит Responseобъекты, которые были созданы для выполнения запроса. Список отсортирован от самого старого до самого последнего ответа.

Например, GitHub перенаправляет все HTTP-запросы на HTTPS:

r = requests.get('http://github.com/')

r.url
'https://github.com/'

r.status_code
200

r.history
[<Response [301]>]
Если вы используете GET, OPTIONS, POST, PUT, PATCH или DELETE, вы можете отключить обработку перенаправления с помощью allow_redirectsпараметра:

r = requests.get('http://github.com/', allow_redirects=False)

r.status_code
301

r.history
[]
Если вы используете HEAD, вы также можете включить перенаправление:

r = requests.head('http://github.com/', allow_redirects=True)

r.url
'https://github.com/'

r.history
[<Response [301]>]
Тайм-ауты 
Вы можете указать Requests прекратить ожидание ответа через заданное количество секунд с помощью timeoutпараметра. Почти весь производственный код должен использовать этот параметр почти во всех запросах. Невыполнение этого требования может привести к зависанию программы на неопределенный срок:

requests.get('https://github.com/', timeout=0.001)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)
Примечание
timeoutне является ограничением по времени на всю загрузку ответа; скорее, исключение возникает, если сервер не выдал ответ в течение timeoutсекунд (точнее, если на базовый сокет не было получено ни одного байта в течение timeoutсекунд). Если тайм-аут явно не указан, запросы не будут истекать по времени.

Ошибки и исключения 
В случае возникновения сетевых проблем (например, сбоя DNS, отказа в подключении и т. д.) запросы вызовут исключение ConnectionError.

Response.raise_for_status()вызовет исключение HTTPError, если HTTP-запрос вернул код состояния неудачи.

Если время запроса истекло, Timeoutвозникает исключение.

Если запрос превышает настроенное максимальное количество перенаправлений, TooManyRedirectsвозникает исключение.

Все исключения, которые явно вызывает Requests, наследуются от requests.exceptions.RequestException.

Готовы к большему? Ознакомьтесь с расширенным разделом.



Redirection and History¶
                                                                                                        
                                                                                                        
По умолчанию запросы будут выполнять перенаправление местоположения для всех команд, кроме HEAD.

Мы можем использовать свойство истории объекта Response для отслеживания перенаправления.

Список Response.history содержит объекты Response, созданные для выполнения запроса. Список отсортирован от самого старого ответа до самого последнего.

Например, GitHub перенаправляет все HTTP-запросы на HTTPS:

r = requests.get('http://github.com/')

r.url
'https://github.com/'

r.status_code
200

r.history
[<Response [301]>]



Если вы используете GET, OPTIONS, POST, PUT, PATCH или DELETE, вы можете отключить обработку перенаправления с помощью параметраallow_redirects:


r = requests.get('http://github.com/', allow_redirects=False)

r.status_code
301

r.history
[]


Если вы используете HEAD, вы также можете включить перенаправление:


r = requests.head('http://github.com/', allow_redirects=True)

r.url
'https://github.com/'

r.history
[<Response [301]>] (Солонченко Кирилл)

Passing Parameters In URLs

Часто вам нужно отправить какие-то данные в строку запроса URL-адреса. Если бы вы создавали URL-адрес вручную, эти данные были бы представлены в виде пар ключ/значение в URL-адресе после вопросительного знака, например: httpbin.org/get?key=val. Requests позволяет вам предоставлять эти аргументы в виде словаря строк, используя аргумент ключевого слова params. Например, если вы хотите передать ключ1=значение1 и ключ2=значение2 на httpbin.org/get, вы должны использовать следующий код:

payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.get('https://httpbin.org/get', params=payload)

Вы можете увидеть, что URL-адрес был правильно закодирован, напечатав URL-адрес:

print(r.url)


Обратите внимание, что любой ключ словаря, значение которого равно None, не будет добавлен в строку запроса URL-адреса.

Вы также можете передать список элементов в качестве значения:

payload = {'key1': 'value1', 'key2': ['value2', 'value3']}

r = requests.get('https://httpbin.org/get', params=payload)
print(r.url)
https://httpbin.org/get?key1=value1&key2=value2&key2=value3





