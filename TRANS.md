
# Аутентификация - Authentication
***В этом документе обсуждается использование различных видов аутентификации с запросами.***

***Многие веб-сервисы требуют аутентификации, и существует множество различных типов. Ниже мы описываем различные формы аутентификации, доступные в Requests, от простых до сложных.***

# Базовая аутентификация - Basic Authentication

***Многие веб-сервисы, требующие аутентификации, принимают HTTP Basic Auth. Это самый простой вид, и Requests поддерживает его прямо из "коробки".***

***Выполнять запросы с помощью HTTP Basic Auth очень просто:***

from requests.auth import HTTPBasicAuth basic = HTTPBasicAuth('user', 'pass') requests.get('https://httpbin.org/basic-auth/user/pass', auth=basic) <Response [200]>

***На самом деле, HTTP Basic Auth настолько распространен, что запросы предоставляют удобное сокращение для его использования:***

requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass')) <Response [200]>

***Предоставление учетных данных в кортеже, подобном этому, как в HTTP Basic Auth примере выше.***

# Аутентификационная сеть - netrc Anuthentication

Если метод аутентификации не указан с auth аргументом, запрос попытается получить учетные данные аутентификации для имени хоста URL из файла сети пользователя. Файл netrc переопределяет необработанные заголовки аутентификации HTTP, установленные с помощью headers.

Если учетные данные для имени хоста найдены, запрос отправляется с помощью HTTP Basic Auth.

# Дайджест-аутентификация

Другой очень популярной формой HTTP-аутентификации является дайджест-аутентификация, и Requests также поддерживает ее «из коробки»:

>>>   from requests.auth import HTTPDigestAuth
>>>   url = 'https://httpbin.org/digest-auth/auth/user/pass'
>>>   requests.get(url, auth=HTTPDigestAuth('user', 'pass'))
<Response [200]>

# Перевод текста
Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:

import requests

r = requests.get('https://api.github.com/events')
r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...

Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:

r.encoding
'utf-8'
r.encoding = 'ISO-8859-1'

Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.

CUSTOM HEADERS

Если вы хотите добавить заголовки http к запросу, то просто передайте словарь в параметр headers. Например, в предыдущем примере мы не указали наш user-agent: url = 'https://api.github.com/some/endpoint' headers = {'user-agent': 'my-app/0.0.1'}

r = requests.get(url, headers=headers)

Примечание: пользовательские заголовки имеют меньший приоритет, чем более конкретные источники информации. Например:

- Заголовоки авторизации, установленные с помощью headers =, будут переопределены, если учетные данные указаны в .netrc, что, в свою очередь, будет переопределено параметром auth=. Запросы будут искать файл netrc в /netrc,/_netrc или по пути, указанному переменной среды NETRC.
- Заголовки авторизации будут удалены, если вы будете перенаправлены за пределы хоста.
- Заголовки Proxy-Authorization будут переопределены учетными данными прокси-сервера, указанными в URL-адресе.
- Заголовки Content-Length будут переопределены, когда мы сможем определить длину контента
Более того, запросы вообще не меняют свое поведение в зависимости от того, какие пользовательские заголовки указаны. Заголовки просто передаются в конечный запрос.

Примечание: все значения заголовков должны быть строкой, байт-тестированием или юникодом. Пока это разрешено, рекомендуется избегать передачи значений заголовков юникода
*Ксюша*


# Содержание бинарного ответа 
# **Binary-Reponse-Content**  
 
**Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:**

r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...

**Кодировки gzip и deflate передачи автоматически декодируются для вас.**

**Кодировка передачи br автоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi.**

**Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, можно использовать следующий код:**

from PIL import Image
from io import BytesIO

i = Image.open(BytesIO(r.content))
# **Quickstart **
Хотите начать? Эта страница дает хорошее введение в то, как начать работу с Requests.

Во-первых, убедитесь, что:

Запросы установлены

Запросы актуальны

Давайте начнем с простых примеров.

Сделать запрос 
Сделать запрос с помощью Requests очень просто.

Начните с импорта модуля «Запросы»:
import requests
Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline:

r = requests.get('https://api.github.com/events')
Now, we have a Response object called r. We can get all the information we need from this object.

Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request:

r = requests.post('https://httpbin.org/post', data={'key': 'value'})
Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple:

r = requests.put('https://httpbin.org/put', data={'key': 'value'})
r = requests.delete('https://httpbin.org/delete')
r = requests.head('https://httpbin.org/get')
r = requests.options('https://httpbin.org/get')
Это все хорошо, но это только начало того, что может сделать Requests.

Передача параметров в URL-адресах 
Часто требуется отправить какие-то данные в строке запроса URL. Если бы вы создавали URL вручную, эти данные были бы указаны в виде пар ключ/значение в URL после вопросительного знака, например httpbin.org/get?key=val. Requests позволяет вам предоставлять эти аргументы в виде словаря строк, используя paramsаргумент ключевого слова. Например, если вы хотите передать key1=value1и key2=value2в httpbin.org/get, вы бы использовали следующий код:
payload = {'key1': 'value1', 'key2': 'value2'}
r = requests.get('https://httpbin.org/get', params=payload)
You can see that the URL has been correctly encoded by printing the URL:

print(r.url)
https://httpbin.org/get?key2=value2&key1=value1
Note that any dictionary key whose value is None will not be added to the URL’s query string.

You can also pass a list of items as a value:

payload = {'key1': 'value1', 'key2': ['value2', 'value3']}

r = requests.get('https://httpbin.org/get', params=payload)
print(r.url)
https://httpbin.org/get?key1=value1&key2=value2&key2=value3


Response Content****

Мы можем прочитать содержимое ответа сервера. Рассмотрим еще раз временную шкалу GitHub:
Запросы будут автоматически декодировать контент с сервера. Большинство наборов символов Unicode легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, угаданная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя r.encodingсвойство:
Если вы измените кодировку, запросы будут использовать новое значение r.encodingвсякий раз, когда вы вызываете r.text. Вы можете захотеть сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка содержимого. Например, HTML и XML имеют возможность указывать свою кодировку в своем теле. В таких ситуациях вы должны использовать , r.contentчтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.textс правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали собственную кодировку и зарегистрировали ее в codecsмодуле, вы можете просто использовать имя кодека в качестве значения, r.encodingи Запросы обработают декодирование за вас.
Binary Response Content
Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:

Binary Response Content

# Перевод текста
Мы можем прочитать содержимое ответа сервера. Взгляните еще раз на временную шкалу GitHub:

import requests

r = requests.get('https://api.github.com/events')
r.text
'[{"repository":{"open_issues":0,"url":"https://github.com/...

Запросы автоматически декодируют контент с сервера. Большинство кодировок Юникода легко декодируются.

Когда вы делаете запрос, Requests делает обоснованные предположения о кодировке ответа на основе заголовков HTTP. Кодировка текста, выбранная Requests, используется при доступе к r.text. Вы можете узнать, какую кодировку использует Requests, и изменить ее, используя свойство r.encoding:

r.encoding
'utf-8'
r.encoding = 'ISO-8859-1'

Если вы измените кодировку, Requests будет использовать новое значение r.encoding при каждом вызове r.text. Возможно, вам захочется сделать это в любой ситуации, когда вы можете применить специальную логику для определения того, какой будет кодировка контента. Например, HTML и XML имеют возможность указывать кодировку в своем теле. В подобных ситуациях вам следует использовать r.content, чтобы найти кодировку, а затем установить r.encoding. Это позволит вам использовать r.text с правильной кодировкой.

Запросы также будут использовать пользовательские кодировки, если они вам понадобятся. Если вы создали свою собственную кодировку и зарегистрировали ее в модуле кодеков, вы можете просто использовать имя кодека в качестве значения r.encoding, и Requests выполнит декодирование за вас.(Солонченко Кирилл)

Вы также можете получить доступ к телу ответа в виде байтов для нетекстовых запросов:
r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...

Кодировки передачи gzip и deflate автоматически декодируются.

Кодировка передачи br автоматически декодируется, если установлена ​​библиотека Brotli, например brotli или brotlicffi.

Например, чтобы создать изображение из двоичных данных, возвращаемых запросом, вы можете использовать следующий код:

from PIL import Image
from io import BytesIO

i = Image.open(BytesIO(r.content))


                                                                                                                     СДЕЛАТЬ ЗАПРОС¶
                                                                                                                     
Сделать запрос с помощью Requests очень просто.

Начните с импорта модуля Requests:
import requests

Теперь попробуем получить веб-страницу. Для этого примера давайте возьмем общедоступную временную шкалу GitHub:

r = requests.get('https://api.github.com/events')
Теперь у нас есть объект Response с именем r. Мы можем получить всю необходимую информацию из этого объекта.

Простой API запросов означает, что все формы HTTP-запросов одинаково очевидны. Например, вот как вы делаете запрос HTTP POST:
r = requests.post('https://httpbin.org/post', data={'key': 'value'})
Приятно, правда? А как насчет других типов HTTP-запросов: PUT, DELETE, HEAD и OPTIONS? Все так же просто:

r = requests.put('https://httpbin.org/put', data={'key': 'value'})
r = requests.delete('https://httpbin.org/delete')
r = requests.head('https://httpbin.org/get')
r = requests.options('https://httpbin.org/get')

Это все хорошо, но это только начало того, на что способны Requests.

